/* Module containing functions to interface with the eink display
   Code written by Matt Payne for UC summer scholarship as part the Insulin pump project,
   however thanks to Max Van Empel where some of the code and process was taken from, 
   especially the buffer processing stuff and LUT's.
   18/12/19
 */

/* How does the eink screen work?
   the screen is 152 * 152 pixels, giving a total of 23104 pixels. Each character in the small_font
   code is 8*8 pixels wide, represented as an array of 8 bytes, ie 64 bits of data. therfore divide
   23104 by the 64 bits needed for a character and the eink can display 361 characters at any one 
   time on its display. since the sqrt(361) = 19 the eink has a display of 19 * 19 for this size of 
   character
   Each byte represents one 'row' in that character with each bit set to either 1 or 0 to give
   black or white on the screen, demonstrated using the array for '!' :

   0 0 0 0 0 0 0 0 
   0 1 0 1 1 1 1 1
   0 0 0 0 0 0 0 0
   0 0 0 0 0 0 0 0
   0 0 0 0 0 0 0 0
   0 0 0 0 0 0 0 0
   0 0 0 0 0 0 0 0
   0 0 0 0 0 0 0 0

   The '!' character is formed but must be rotated 90 deg anti clockwise before display which is achieved later in
   the code
 */



#include "eink_luts_and_buf.h"
#include "string.h"
#include "stdint.h"
#include "hal_io.h"
static uint8_t* screen_buffer;
static uint16_t screen_buf_size = (SCREEN_WIDTH * 152)/8;
extern struct io_descriptor *spi_io;

// allocate memory to the screen buffer
void initialise_buffer()
{
	screen_buffer = (uint8_t*)malloc(screen_buf_size);
}

// set all entries in buffer to 0
void clear_buffer()
{
	uint16_t i = 0;
    while(i <= screen_buf_size)
	{
		screen_buffer[i] = 0;
		i++;
	}
}

// get the string length then divide it by 19 to work out how many rows are required on the eink screen
uint8_t calculate_rows(char* text)
{
    return (strlen(text)/19) + 1;
}

// get the string and split it into rows of length 19 to write onto the screen
void split_string_to_rows(unsigned char* string, char row_array[][20], uint8_t rows)
{
	uint8_t i;
	uint8_t j;
	for (i = 0; i < rows; i++)
		{
			for (j = 0; j < 19; j++)
			{
				row_array[i][j] = string[(i * 19) + j];

				if (row_array[i][j] == '\0')
				{
					return;
				}
			}
		}
	row_array[i][19] = '\0';
}

// create an array that stores index in LUT of each character in the string
void get_font_index(char* string, uint8_t* font_index_array)
{
	uint8_t i;
	for (i = 0; string[i] != '\0'; i++)
	{
		if (string[i] >= 'a' && string[i] <= 'z') { //extract and convert lowercase characters as fonts has uppercase only
			font_index_array[i] = 33 + (string[i] - 'a');
		} else if (string[i] >= ' ' && string[i] <= 'Z') { // take valid characters and add the required offset for LUT
			font_index_array[i] = string[i] - ASCII_TO_LUT_OFFSET;
		} else {
			font_index_array[i] = 0; // just make any invalid character a 0 in the array
		}
	}
}

// rotate characters 90 deg clockwise because read the text at the top.
void rotate_character(const unsigned char* character, unsigned char* rotated_character)
{
	uint8_t i;
	uint8_t j;
	for (i = 0; i < 8; i++)
	{
		for (j = 8; j > 0; j--)
		{
			if ((character[j]) & (0x01 << i)) {
				rotated_character[i] += 1 << (7-j);
			}
			
		}
		if (rotated_character[i] > 127) {
			rotated_character[i] = 127;
		}
	}
}

void fill_screen_buffer(char* string, uint8_t x, uint8_t y)
{
	uint8_t i;
	uint8_t j;	
	uint8_t k;
	uint8_t string_length  = strlen(string);
	uint8_t font_index_array[string_length];
	// sets up an array of font index locations of each character in the string
	get_font_index(string, font_index_array);
	for (i = 0; i < string_length; i++)
	{
		unsigned char current_char[CHAR_WIDTH];
		// reset all elements of the array to zero
		for (j = 0; j < CHAR_WIDTH; j++)
		{
			current_char[j] = 0;
		}
		rotate_character(small_font[font_index_array[i]], &current_char);
		for (k = 0; k < 8; k++) 
		{
			uint16_t buf_index = (x/8) + ((k + y) * BYTES_WIDTH) + i;
			
			if(buf_index > (screen_buf_size - 1))
			{
				buf_index = screen_buf_size - 1;
			}
			screen_buffer[buf_index] = current_char[k];		
		}
	}	
}

void send_screen_buffer()
{
	io_write(spi_io, screen_buffer, screen_buf_size);
}

const unsigned char small_font[60][8] = {
	
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //
	{0x00,0x5f,0x00,0x00,0x00,0x00,0x00,0x00}, // !
	{0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00}, // "
	{0x0a,0x1f,0x0a,0x1f,0x0a,0x00,0x00,0x00}, // #
	{0x24,0x2a,0x2a,0x7f,0x2a,0x2a,0x12,0x00}, // $
	{0x00,0x47,0x25,0x17,0x08,0x74,0x52,0x71}, // %
	{0x00,0x36,0x49,0x49,0x49,0x41,0x41,0x38}, // &
	{0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00}, // '
	{0x00,0x3e,0x41,0x00,0x00,0x00,0x00,0x00}, // (
	{0x41,0x3e,0x00,0x00,0x00,0x00,0x00,0x00}, // )
	{0x04,0x15,0x0e,0x15,0x04,0x00,0x00,0x00}, // *
	{0x08,0x08,0x3e,0x08,0x08,0x00,0x00,0x00}, // +
	{0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00}, // ,
	{0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00}, // -
	{0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // .
	{0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00}, // /
	{0x00,0x3e,0x61,0x51,0x49,0x45,0x43,0x3e}, // 0
	{0x00,0x00,0x01,0x01,0x7e,0x00,0x00,0x00}, // 1
	{0x00,0x71,0x49,0x49,0x49,0x49,0x49,0x46}, // 2
	{0x41,0x49,0x49,0x49,0x49,0x49,0x36,0x00}, // 3
	{0x00,0x0f,0x10,0x10,0x10,0x10,0x10,0x7f}, // 4
	{0x00,0x4f,0x49,0x49,0x49,0x49,0x49,0x31}, // 5
	{0x00,0x3e,0x49,0x49,0x49,0x49,0x49,0x30}, // 6
	{0x01,0x01,0x01,0x01,0x01,0x01,0x7e,0x00}, // 7
	{0x00,0x36,0x49,0x49,0x49,0x49,0x49,0x36}, // 8
	{0x00,0x06,0x49,0x49,0x49,0x49,0x49,0x3e}, // 9
	{0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // :
	{0x40,0x34,0x00,0x00,0x00,0x00,0x00,0x00}, // ;
	{0x08,0x14,0x22,0x00,0x00,0x00,0x00,0x00}, // <
	{0x14,0x14,0x14,0x14,0x14,0x00,0x00,0x00}, // =
	{0x22,0x14,0x08,0x00,0x00,0x00,0x00,0x00}, // >
	{0x00,0x06,0x01,0x01,0x59,0x09,0x09,0x06}, // ?
	{0x00,0x3e,0x41,0x5d,0x55,0x5d,0x51,0x5e}, // @
	{0x00,0x7e,0x01,0x09,0x09,0x09,0x09,0x7e}, // A
	{0x00,0x7f,0x41,0x49,0x49,0x49,0x49,0x36}, // B
	{0x00,0x3e,0x41,0x41,0x41,0x41,0x41,0x22}, // C
	{0x00,0x7f,0x41,0x41,0x41,0x41,0x41,0x3e}, // D
	{0x00,0x3e,0x49,0x49,0x49,0x49,0x49,0x41}, // E
	{0x00,0x7e,0x09,0x09,0x09,0x09,0x09,0x01}, // F
	{0x00,0x3e,0x41,0x49,0x49,0x49,0x49,0x79}, // G
	{0x00,0x7f,0x08,0x08,0x08,0x08,0x08,0x7f}, // H
	//{0x00,0x7f,0x00,0x00,0x00,0x00,0x00,0x00}, // I
	{0x00,0x41,0x41,0x41,0x7F,0x41,0x41,0x41}, //My I
	{0x00,0x38,0x40,0x40,0x41,0x41,0x41,0x3f}, // J
	{0x00,0x7f,0x08,0x08,0x08,0x0c,0x0a,0x71}, // K
	{0x00,0x3f,0x40,0x40,0x40,0x40,0x40,0x40}, // L
	{0x00,0x7e,0x01,0x01,0x7e,0x01,0x01,0x7e}, // M
	{0x00,0x7e,0x01,0x01,0x3e,0x40,0x40,0x3f}, // N
	{0x00,0x3e,0x41,0x41,0x41,0x41,0x41,0x3e}, // O
	{0x00,0x7e,0x09,0x09,0x09,0x09,0x09,0x06}, // P
	{0x00,0x3e,0x41,0x41,0x71,0x51,0x51,0x7e}, // Q
	{0x00,0x7e,0x01,0x31,0x49,0x49,0x49,0x46}, // R
	//{0x00,0x46,0x49,0x49,0x49,0x49,0x49,0x31}, // S
	{0x00,0x46,0x49,0x49,0x49,0x49,0x49,0x32}, //My S
	{0x01,0x01,0x01,0x7f,0x01,0x01,0x01,0x00}, // T
	{0x00,0x3f,0x40,0x40,0x40,0x40,0x40,0x3f}, // U
	{0x00,0x0f,0x10,0x20,0x40,0x20,0x10,0x0f}, // V
	{0x00,0x3f,0x40,0x40,0x3f,0x40,0x40,0x3f}, // W
	{0x00,0x63,0x14,0x08,0x08,0x08,0x14,0x63}, // X
	{0x00,0x07,0x08,0x08,0x78,0x08,0x08,0x07}, // Y
	{0x00,0x71,0x49,0x49,0x49,0x49,0x49,0x47}, // Z
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
};

